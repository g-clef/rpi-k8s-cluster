---
# roles/nfs_roots/tasks/build_per_node.yml
# Uses vars from main: base_root_dir, upper_root_dir, work_root_dir, work_dir, tftp_root, per_node_root_base

# 1) Identity pieces first (don't reference these in the same set_fact)
- name: Compute node identity
  ansible.builtin.set_fact:
    node_name: "{{ hostvars[node].hostname }}"
    node_mac_id: "{{ hostvars[node].mac | lower | replace(':','-') }}"

# 2) Now compute paths that can safely use the above
- name: Compute node paths
  ansible.builtin.set_fact:
    node_root: "{{ per_node_root_base }}/{{ node_name }}"
    node_tftp: "{{ tftp_root }}/{{ node_mac_id }}"
    node_upper: "{{ upper_root_dir }}/{{ node_name }}"
    node_work:  "{{ work_root_dir  }}/{{ node_name }}"

- name: Setup overlay filesystem infrastructure
  block:
    - name: Prepare directories (mountpoint and per-node upper/work, TFTP)
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      loop:
        - "{{ node_root }}"
        - "{{ node_upper }}"
        - "{{ node_work }}"
        - "{{ node_tftp }}"

    - name: Load overlayfs kernel module (no-fail if already loaded)
      ansible.builtin.command: modprobe overlay
      changed_when: false
      failed_when: false

    - name: Persist overlay module at boot
      ansible.builtin.copy:
        dest: /etc/modules-load.d/overlay.conf
        content: "overlay\n"
        mode: "0644"
  become: true

# Persist and mount overlay
- name: Ensure overlay mount present in fstab
  ansible.posix.mount:
    path: "{{ node_root }}"
    src: "overlay"
    fstype: overlay
    opts: "lowerdir={{ base_root_dir }},upperdir={{ node_upper }},workdir={{ node_work }}"
    state: present
  become: true

- name: Mount overlay (lower=base, upper/work per-node)
  ansible.posix.mount:
    path: "{{ node_root }}"
    src: "overlay"
    fstype: overlay
    opts: "lowerdir={{ base_root_dir }},upperdir={{ node_upper }},workdir={{ node_work }}"
    state: mounted
  become: true

# --- Per-node customizations (written into overlay upper) ---

- name: Configure node system settings
  block:
    - name: Set hostname
      ansible.builtin.copy:
        dest: "{{ node_root }}/etc/hostname"
        content: "{{ node_name }}\n"
        mode: "0644"

    - name: Update /etc/hosts
      ansible.builtin.lineinfile:
        path: "{{ node_root }}/etc/hosts"
        regexp: '^127\.0\.1\.1\s+'
        line: "127.0.1.1\t{{ node_name }}"
        create: true

    - name: Add tmpfs entries to /etc/fstab
      ansible.builtin.blockinfile:
        path: "{{ node_root }}/etc/fstab"
        block: |
          tmpfs /var/log tmpfs defaults,noatime,nosuid,size={{ tmpfs_var_log_size }} 0 0
          tmpfs /tmp     tmpfs defaults,noatime,nosuid,size={{ tmpfs_tmp_size }}     0 0
  become: true

# --- SSH Configuration ---

- name: Configure SSH service and settings
  block:
    - name: Enable SSH service on Pi nodes
      ansible.builtin.file:
        path: "{{ node_root }}/etc/systemd/system/multi-user.target.wants/ssh.service"
        src: "/lib/systemd/system/ssh.service"
        state: link

    - name: Ensure SSH directory exists
      ansible.builtin.file:
        path: "{{ node_root }}/etc/ssh"
        state: directory
        mode: "0755"

    - name: Configure SSH for initial setup
      ansible.builtin.blockinfile:
        path: "{{ node_root }}/etc/ssh/sshd_config"
        create: true
        block: |
          PermitRootLogin yes
          PasswordAuthentication yes
        marker: "# {mark} ANSIBLE MANAGED - Initial SSH Config"
  become: true

# --- Pi User Configuration ---

- name: Read current user's authorized_keys if available
  ansible.builtin.slurp:
    src: "{{ ansible_env.HOME }}/.ssh/authorized_keys"
  register: ansible_user_authorized_keys
  ignore_errors: true
  run_once: true

- name: Set final authorized keys list
  ansible.builtin.set_fact:
    final_authorized_keys: >-
      {{ 
        pi_ssh_authorized_keys 
        if (pi_ssh_authorized_keys | length > 0) 
        else (
          (ansible_user_authorized_keys.content | b64decode).split('\n') 
          | select('match', '^ssh-') 
          | list
          if ansible_user_authorized_keys is succeeded 
          else []
        )
      }}

- name: Configure pi user with SSH access
  block:
    - name: Create pi user with sudo privileges
      ansible.builtin.user:
        name: "{{ pi_ssh_user }}"
        password: "{{ pi_ssh_password | password_hash('sha512') }}"
        groups: sudo
        shell: /bin/bash
        create_home: true
        home: "/home/{{ pi_ssh_user }}"
      vars:
        ansible_chroot: "{{ node_root }}"

    - name: Add pi user to sudoers for passwordless sudo
      ansible.builtin.lineinfile:
        path: "{{ node_root }}/etc/sudoers"
        line: "{{ pi_ssh_user }} ALL=(ALL) NOPASSWD:ALL"
        validate: 'visudo -cf %s'

    - name: Configure SSH keys for pi user
      block:
        - name: Create .ssh directory for pi user
          ansible.builtin.file:
            path: "{{ node_root }}/home/{{ pi_ssh_user }}/.ssh"
            state: directory
            mode: "0700"
            owner: 1000
            group: 1000

        - name: Add authorized keys for pi user
          ansible.builtin.copy:
            content: "{{ final_authorized_keys | join('\n') }}\n"
            dest: "{{ node_root }}/home/{{ pi_ssh_user }}/.ssh/authorized_keys"
            mode: "0600"
            owner: 1000
            group: 1000
      when: final_authorized_keys | length > 0
  become: true

# --- TFTP boot files: shared + per-node cmdline.txt ---

- name: Determine boot source directory
  ansible.builtin.set_fact:
    boot_src_dir: "{{ firmware_boot_dir | default(work_dir ~ '/firmware-master/boot') }}"

- name: Ensure boot source directory exists
  ansible.builtin.stat:
    path: "{{ boot_src_dir }}"
  register: boot_src_stat

- name: Fail if boot source dir is missing
  ansible.builtin.fail:
    msg: "Boot files not found at {{ boot_src_dir }}. Ensure the firmware download/unpack step ran earlier."
  when: not boot_src_stat.stat.exists

- name: Populate node TFTP dir (hard-link clone of boot files)
  ansible.builtin.command: >
    rsync -a --delete
    --link-dest="{{ boot_src_dir }}/"
    --out-format='<<CHANGED>>%i %n%L'
    "{{ boot_src_dir }}/"
    "{{ node_tftp }}/"
  register: rsync_boot
  changed_when: "'<<CHANGED>>' in rsync_boot.stdout"
  become: true

- name: Copy additional required boot files from TFTP root to node directory
  ansible.builtin.copy:
    src: "{{ tftp_root }}/{{ item }}"
    dest: "{{ node_tftp }}/{{ item }}"
    remote_src: true
    mode: "0644"
  loop:
    - armstub8-gic.bin
    - kernel8.img
    - bcm2711-rpi-4-b.dtb
    - bcm2711-rpi-400.dtb
    - bcm2711-rpi-cm4.dtb
  become: true
  ignore_errors: true

- name: Write per-node cmdline.txt (NFS root)
  ansible.builtin.template:
    src: cmdline.txt.j2
    dest: "{{ node_tftp }}/cmdline.txt"
    mode: "0644"
  vars:
    node_hostname: "{{ node_name }}"
  become: true

- name: Create per-node config.txt (only node-specific overrides)
  ansible.builtin.copy:
    dest: "{{ node_tftp }}/config.txt"
    content: |
      # Per-node netboot configuration for {{ node_name }}
      arm_64bit=1
      enable_uart=0
      uart_2ndstage=0
      gpu_mem=16
      program_usb_boot_mode=1
      dtparam=audio=off
      dtparam=spi=off
      dtparam=i2c=off
      enable_ssh=1
      boot_delay=3
      dtoverlay=disable-wifi
      dtoverlay=disable-bt
      # Completely disable UART and debug features
      disable_splash=1
      avoid_warnings=1
      kernel_address=0x200000
      kernel_old=1
    mode: "0644"
  become: true

- name: Set proper permissions on TFTP node directory
  ansible.builtin.file:
    path: "{{ node_tftp }}"
    owner: nobody
    group: nogroup
    mode: '0755'
    recurse: true
  become: true
