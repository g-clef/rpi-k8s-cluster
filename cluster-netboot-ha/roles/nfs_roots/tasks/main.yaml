---
# roles/nfs_roots/tasks/main.yaml
#
# Vars you should set (group_vars/all.yml or role defaults):
#   work_dir: /srv/rpi-build
#   raspios_url: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
#   per_node_root_base: /mnt/nfsroot/roots   # LOCAL path that nas-vm exports to Pis
#   tftp_root: /srv/tftp                     # LOCAL
#   tmpfs_var_log_size: 64M
#   tmpfs_tmp_size: 64M
# Optional (can override):
#   overlay_root: /var/lib/rpi-overlays      # LOCAL; holds base + all uppers/works

- name: Set sane defaults for overlay_root
  ansible.builtin.set_fact:
    overlay_root: "{{ overlay_root | default('/var/lib/rpi-overlays') }}"

# --- Prep: dirs & tools -------------------------------------------------------

- name: Ensure working directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ work_dir }}"
    - "{{ work_dir }}/mnt_boot"
    - "{{ work_dir }}/mnt_root"
  become: true

- name: Ensure required tools are present
  ansible.builtin.package:
    name:
      - unzip
      - xz-utils
      - file
      - rsync
  become: true

# --- Download image (patient/retriable) ---------------------------------------

- name: Download Raspberry Pi OS image (patient + retries)
  ansible.builtin.get_url:
    url: "{{ raspios_url }}"
    dest: "{{ work_dir }}/{{ raspios_url | basename }}"
    mode: "0644"
    force: false
    timeout: 1800
    tmp_dest: "{{ work_dir }}"
  register: raspios_dl
  retries: 5
  delay: 15
  until: raspios_dl is succeeded

- name: Detect downloaded file type
  ansible.builtin.command:
    cmd: file -b --mime-type "{{ work_dir }}/{{ raspios_url | basename }}"
  register: raspios_mime
  changed_when: false

- name: Abort if we fetched an HTML/text page instead of an archive
  ansible.builtin.fail:
    msg: >-
      Downloaded {{ raspios_url | basename }} is {{ raspios_mime.stdout }},
      which suggests a bad URL or network/auth issue. Check raspios_url.
  when: raspios_mime.stdout in ['text/html', 'text/plain']

# --- Normalize names & extract to .img ----------------------------------------

- name: Normalize archive + image names and img_path
  ansible.builtin.set_fact:
    raspios_archive: "{{ work_dir }}/{{ raspios_url | basename }}"
    raspios_img: "{{ work_dir }}/{{ (raspios_url | basename)
                    | regex_replace('\\.img\\.xz$', '.img')
                    | regex_replace('\\.xz$', '')
                    | regex_replace('\\.zip$', '') }}"
    img_path: "{{ work_dir }}/{{ (raspios_url | basename)
                 | regex_replace('\\.img\\.xz$', '.img')
                 | regex_replace('\\.xz$', '')
                 | regex_replace('\\.zip$', '') }}"

- name: Unpack ZIP → IMG (legacy images)
  ansible.builtin.unarchive:
    src: "{{ raspios_archive }}"
    dest: "{{ work_dir }}"
    remote_src: true
  when: raspios_mime.stdout == 'application/zip'
  become: true

- name: Extract .xz → .img if needed (keep archive; idempotent)
  ansible.builtin.shell: |
    set -euo pipefail
    xz -tv "{{ raspios_archive }}" 1>/dev/null
    xz -dc "{{ raspios_archive }}" > "{{ raspios_img }}"
  args:
    executable: /bin/bash
    creates: "{{ raspios_img }}"
  when: raspios_mime.stdout in ['application/x-xz', 'application/octet-stream']
  become: true

- name: Verify extracted image looks sane
  ansible.builtin.command: file -b "{{ img_path }}"
  register: img_kind
  changed_when: false

- name: Fail if image is missing or still compressed/invalid
  ansible.builtin.fail:
    msg: >-
      Expected an uncompressed disk image at {{ img_path }}; got: {{ img_kind.stdout }}.
      Ensure there is enough free space (3–4 GB) and try again.
  when: img_kind.stdout is search('XZ compressed data|text/html|text/plain') or
        img_kind.stdout is not search('DOS/MBR|partition|filesystem|disk image')

# --- Loop device with partition scan; mount p1/p2 -----------------------------

- name: Create loop device with partition scan (-P)
  ansible.builtin.command: "losetup -f --show -P {{ img_path }}"
  register: loopdev
  changed_when: true
  become: true

- name: Settle udev
  ansible.builtin.command: "udevadm settle"
  changed_when: false
  become: true

- name: Wait for loop partition device nodes to appear
  ansible.builtin.stat:
    path: "{{ item }}"
  register: part_nodes
  until: part_nodes.stat.exists
  retries: 10
  delay: 1
  loop:
    - "{{ loopdev.stdout }}p1"
    - "{{ loopdev.stdout }}p2"
  become: true

- name: Remember loop and partition devices
  ansible.builtin.set_fact:
    loop_device: "{{ loopdev.stdout }}"
    boot_device: "{{ loopdev.stdout }}p1"
    root_device: "{{ loopdev.stdout }}p2"

- name: Mount boot partition (p1)
  ansible.posix.mount:
    path: "{{ work_dir }}/mnt_boot"
    src: "{{ boot_device }}"
    fstype: vfat
    state: mounted
  become: true

- name: Mount root partition (p2)
  ansible.posix.mount:
    path: "{{ work_dir }}/mnt_root"
    src: "{{ root_device }}"
    fstype: ext4
    state: mounted
  become: true

# --- Build shared read-only base on LOCAL disk --------------------------------

- name: Define base + overlay roots (LOCAL)
  ansible.builtin.set_fact:
    base_root_dir: "{{ overlay_root }}/base"
    upper_root_dir: "{{ overlay_root }}/upper"
    work_root_dir:  "{{ overlay_root }}/work"

- name: Ensure LOCAL overlay roots exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ overlay_root }}"
    - "{{ base_root_dir }}"
    - "{{ upper_root_dir }}"
    - "{{ work_root_dir }}"
    - "{{ per_node_root_base }}"
  become: true

- name: Rsync image root → shared LOCAL base (once)
  ansible.builtin.command: >
    rsync -a --delete --numeric-ids
    --exclude='/dev/*' --exclude='/proc/*' --exclude='/sys/*' --exclude='/run/*'
    --out-format='<<CHANGED>>%i %n%L'
    "{{ work_dir }}/mnt_root/"
    "{{ base_root_dir }}/"
  register: rsync_base
  changed_when: "'<<CHANGED>>' in rsync_base.stdout"
  become: true
  run_once: true

# --- Per-node overlay + TFTP --------------------------------------------------

- name: Build per-node roots and TFTP subdirs (overlayfs)
  ansible.builtin.include_tasks: build_per_node.yml
  loop: "{{ (groups['pi_servers'] | default([])) + (groups['pi_agents'] | default([])) }}"
  loop_control:
    loop_var: node
    label: "{{ hostvars[node].hostname | default(node) }}"

# --- Cleanup: unmount & detach loop ------------------------------------------

- name: Unmount boot
  ansible.posix.mount:
    path: "{{ work_dir }}/mnt_boot"
    state: unmounted
  become: true

- name: Unmount root
  ansible.posix.mount:
    path: "{{ work_dir }}/mnt_root"
    state: unmounted
  become: true

- name: Detach loop device
  ansible.builtin.command: "losetup -d {{ loop_device }}"
  when: loop_device is defined
  changed_when: true
  become: true
