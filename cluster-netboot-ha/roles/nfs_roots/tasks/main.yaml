---
# roles/nfs_roots/tasks/main.yaml

# Expected vars (e.g., group_vars/all.yml or role defaults):
# work_dir: /srv/rpi-build
# raspios_url: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
# per_node_root_base: /srv/nfs-roots
# tftp_root: /srv/tftp
# tmpfs_var_log_size: 64M
# tmpfs_tmp_size: 64M
# Inventory groups: pi_servers, pi_agents (hosts must have vars: hostname, mac)

- name: Ensure working directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ work_dir }}"
    - "{{ work_dir }}/mnt_boot"
    - "{{ work_dir }}/mnt_root"
  become: true

- name: Ensure required tools are present
  ansible.builtin.package:
    name:
      - unzip
      - xz-utils
      - file
      - rsync
    state: present
  become: true

- name: Download Raspberry Pi OS image (patient + retries)
  ansible.builtin.get_url:
    url: "{{ raspios_url }}"
    dest: "{{ work_dir }}/{{ raspios_url | basename }}"
    mode: "0644"
    force: false
    timeout: 1800              # 30m per-request read timeout
    tmp_dest: "{{ work_dir }}" # write temp file in same FS (if supported)
  register: raspios_dl
  retries: 5
  delay: 15
  until: raspios_dl is succeeded

- name: Detect downloaded file type
  ansible.builtin.command:
    cmd: file -b --mime-type "{{ work_dir }}/{{ raspios_url | basename }}"
  register: raspios_mime
  changed_when: false

- name: Abort if we fetched an HTML/text page instead of an archive
  ansible.builtin.fail:
    msg: >-
      Downloaded {{ raspios_url | basename }} is {{ raspios_mime.stdout }},
      which suggests a bad URL or network/auth issue. Check raspios_url.
  when: raspios_mime.stdout in ['text/html', 'text/plain']

# Work out names for .xz and expected .img
- name: Derive archive and image names
  ansible.builtin.set_fact:
    raspios_archive: "{{ raspios_url | basename }}"
    raspios_img: "{{ (raspios_url | basename) | regex_replace('\\.xz$', '') }}"

# Handle legacy .zip -> .img
- name: Unpack ZIP → IMG (legacy images)
  ansible.builtin.unarchive:
    src: "{{ work_dir }}/{{ raspios_archive }}"
    dest: "{{ work_dir }}"
    remote_src: true
  when: raspios_archive is match('\\.zip$')

# For .img.xz, only unxz if .img isn't already present (idempotent)
- name: Check if IMG already exists (from previous run)
  ansible.builtin.stat:
    path: "{{ work_dir }}/{{ raspios_img }}"
  register: raspios_img_stat
  when: raspios_archive is match('\\.xz$')

- name: Unpack XZ → IMG (current images, on demand)
  ansible.builtin.command:
    cmd: "unxz -T0 -f {{ work_dir }}/{{ raspios_archive }}"
    chdir: "{{ work_dir }}"
  when:
    - raspios_archive is match('\\.xz$')
    - not raspios_img_stat.stat.exists | default(false)

# Verify that we now have an .img
- name: Stat extracted IMG
  ansible.builtin.stat:
    path: "{{ work_dir }}/{{ raspios_img }}"
  register: raspios_img_after

# If no .img, try to diagnose the archive and fail helpfully
- name: Diagnose archive if IMG missing (xz -tv)
  ansible.builtin.command:
    cmd: "xz -tv {{ work_dir }}/{{ raspios_archive }}"
  register: xz_verify
  changed_when: false
  failed_when: false
  when:
    - raspios_archive is match('\\.xz$')
    - not raspios_img_after.stat.exists

- name: Fail if no .img found after extraction
  ansible.builtin.fail:
    msg: >-
      No .img file found in {{ work_dir }} after unpacking {{ raspios_archive }}.
      xz -tv output:
      {{ (xz_verify.stdout | default('')) + (xz_verify.stderr | default('')) }}
  when: not raspios_img_after.stat.exists

# img_path is now known explicitly
- name: Set image path
  ansible.builtin.set_fact:
    img_path: "{{ work_dir }}/{{ raspios_img }}"

- name: Get partition table
  ansible.builtin.command:
    cmd: "fdisk -l {{ img_path }}"
  register: fdisk_out
  changed_when: false

- name: Parse partition starts (with sane fallbacks)
  ansible.builtin.set_fact:
    sector_size: 512
    boot_start: >-
      {{ (
          fdisk_out.stdout
          | regex_search(
              '^\s*' ~ (img_path | regex_escape) ~ '.*\n\s*'
              ~ (img_path | regex_escape) ~ 'p*\s*\d+\s+(\d+)\s+\d+\s+\d+\s+.*(W95|EFI)',
              multiline=True
            )
          | default(['8192'])
          | first
          | int
        )
      }}
    root_start: >-
      {{ (
          fdisk_out.stdout
          | regex_search('Linux\s+filesystem\s+\d+\s+(\d+)', multiline=True)
          | default(['532480'])
          | first
          | int
        )
      }}

- name: Mount boot partition from image
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_boot"
    src: "{{ img_path }}"
    fstype: vfat
    opts: "loop,offset={{ (boot_start | int) * (sector_size | int) }}"
    state: mounted
  become: true

- name: Mount root partition from image
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_root"
    src: "{{ img_path }}"
    fstype: ext4
    opts: "loop,offset={{ (root_start | int) * (sector_size | int) }}"
    state: mounted
  become: true

- name: Ensure per-node base dir exists
  ansible.builtin.file:
    path: "{{ per_node_root_base }}"
    state: directory
    mode: "0755"
  become: true

# --- Per-node work ---
- name: Build per-node roots and TFTP subdirs
  ansible.builtin.include_tasks: build_per_node.yml
  loop: "{{ (groups['pi_servers'] | default([])) + (groups['pi_agents'] | default([])) }}"
  loop_control:
    loop_var: node
    label: "{{ hostvars[node].hostname | default(node) }}"

# --- Cleanup mounts ---
- name: Unmount boot
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_boot"
    state: unmounted
  become: true

- name: Unmount root
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_root"
    state: unmounted
  become: true
