---
# roles/nfs_roots/tasks/main.yaml

# Expected vars (e.g., group_vars/all.yml or role defaults):
# work_dir: /srv/rpi-build
# raspios_url: "https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz"
# per_node_root_base: /srv/nfs-roots
# tftp_root: /srv/tftp
# tmpfs_var_log_size: 64M
# tmpfs_tmp_size: 64M
# Inventory groups: pi_servers, pi_agents (hosts must have vars: hostname, mac)

- name: Ensure working directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ work_dir }}"
    - "{{ work_dir }}/mnt_boot"
    - "{{ work_dir }}/mnt_root"
  become: true

- name: Ensure required tools are present
  ansible.builtin.package:
    name:
      - unzip
      - xz-utils
      - file
      - rsync
    state: present
  become: true

- name: Download Raspberry Pi OS image (patient + retries)
  ansible.builtin.get_url:
    url: "{{ raspios_url }}"
    dest: "{{ work_dir }}/{{ raspios_url | basename }}"
    mode: "0644"
    force: false
    timeout: 1800
    tmp_dest: "{{ work_dir }}"
  register: raspios_dl
  retries: 5
  delay: 15
  until: raspios_dl is succeeded

- name: Detect downloaded file type
  ansible.builtin.command:
    cmd: file -b --mime-type "{{ work_dir }}/{{ raspios_url | basename }}"
  register: raspios_mime
  changed_when: false

- name: Abort if we fetched an HTML/text page instead of an archive
  ansible.builtin.fail:
    msg: >-
      Downloaded {{ raspios_url | basename }} is {{ raspios_mime.stdout }},
      which suggests a bad URL or network/auth issue. Check raspios_url.
  when: raspios_mime.stdout in ['text/html', 'text/plain']

# Compute archive and the **intended** image path
- name: Derive archive and image names
  ansible.builtin.set_fact:
    raspios_archive: "{{ raspios_url | basename }}"
    raspios_img: '{{ (raspios_url | basename)
                     | regex_replace("\\.img\\.xz$", ".img")
                     | regex_replace("\\.xz$", "")
                     | regex_replace("\\.zip$", "") }}'


# Unpack legacy .zip archives
- name: Unpack ZIP → IMG (legacy images)
  ansible.builtin.unarchive:
    src: "{{ work_dir }}/{{ raspios_archive }}"
    dest: "{{ work_dir }}"
    remote_src: true
  when: raspios_mime.stdout in ['application/zip']

# Unpack .xz archives (keep archive; write explicit img)
- name: Check if IMG already exists (idempotent)
  ansible.builtin.stat:
    path: "{{ work_dir }}/{{ raspios_img }}"
  register: raspios_img_stat

- name: Extract XZ → IMG (deterministic, keep archive)
  ansible.builtin.shell: |
    set -euo pipefail
    xz -tv "{{ work_dir }}/{{ raspios_archive }}" 1>/dev/null
    xz -dc "{{ work_dir }}/{{ raspios_archive }}" > "{{ work_dir }}/{{ raspios_img }}"
  args:
    executable: /bin/bash
  when:
    - raspios_mime.stdout in ['application/x-xz', 'application/octet-stream']
    - not raspios_img_stat.stat.exists
  register: xz_extract

# Verify that we now have a plausible .img (size > 100 MB)
- name: Stat extracted IMG
  ansible.builtin.stat:
    path: "{{ work_dir }}/{{ raspios_img }}"
  register: raspios_img_after

- name: Fail if no .img found or file looks too small
  ansible.builtin.fail:
    msg: >-
      Expected IMG at {{ work_dir }}/{{ raspios_img }} after unpacking {{ raspios_archive }},
      but it was {{ 'missing' if not raspios_img_after.stat.exists else (raspios_img_after.stat.size ~ ' bytes') }}.
      Archive MIME: {{ raspios_mime.stdout }}.
      If this is an .xz, try manually: xz -tv {{ work_dir }}/{{ raspios_archive }}
  when: (not raspios_img_after.stat.exists) or (raspios_img_after.stat.size | int < 100*1024*1024)

- name: Set image path
  ansible.builtin.set_fact:
    img_path: "{{ work_dir }}/{{ raspios_img }}"


# img_path is now known explicitly
- name: Set image path
  ansible.builtin.set_fact:
    img_path: "{{ work_dir }}/{{ raspios_img }}"

- name: Get partition table
  ansible.builtin.command:
    cmd: "fdisk -l -o Device,Start,Type {{ img_path }}"
  register: fdisk_out
  changed_when: false

# Optional: flip to 'true' once to see what fdisk actually prints on your box
- name: Debug fdisk output (one-time)
  ansible.builtin.debug:
    var: fdisk_out.stdout
  when: false

- name: Parse partition starts (robust + safe fallbacks)
  ansible.builtin.set_fact:
    sector_size: 512

    # Boot partition start sector:
    # Look for a line like:
    #   /path/image.imgp1   8192   EFI System
    #   /path/image.imgp1   8192   W95 FAT32 (LBA)
    #   /path/image.imgp1   8192   Microsoft basic data
    boot_start: >-
      {{
        (
          fdisk_out.stdout
          | regex_search(
              '^' ~ (img_path | regex_escape) ~ 'p?\d+\s+(\d+)\s+.*(EFI System|W95 FAT32|Microsoft basic data|FAT)',
              multiline=True, ignorecase=True
            )
          | default([], true)        # if None → []
          | first(default='8192')    # default to 8192 if still empty
          | int
        )
      }}

    # Root partition start sector:
    # Usually reported as "Linux filesystem"
    root_start: >-
      {{
        (
          fdisk_out.stdout
          | regex_search(
              '^' ~ (img_path | regex_escape) ~ 'p?\d+\s+(\d+)\s+.*Linux filesystem',
              multiline=True, ignorecase=True
            )
          | default([], true)
          | first(default='532480')
          | int
        )
      }}


- name: Mount boot partition from image
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_boot"
    src: "{{ img_path }}"
    fstype: vfat
    opts: "loop,offset={{ (boot_start | int) * (sector_size | int) }}"
    state: mounted
  become: true

- name: Mount root partition from image
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_root"
    src: "{{ img_path }}"
    fstype: ext4
    opts: "loop,offset={{ (root_start | int) * (sector_size | int) }}"
    state: mounted
  become: true

- name: Ensure per-node base dir exists
  ansible.builtin.file:
    path: "{{ per_node_root_base }}"
    state: directory
    mode: "0755"
  become: true

# --- Per-node work ---
- name: Build per-node roots and TFTP subdirs
  ansible.builtin.include_tasks: build_per_node.yml
  loop: "{{ (groups['pi_servers'] | default([])) + (groups['pi_agents'] | default([])) }}"
  loop_control:
    loop_var: node
    label: "{{ hostvars[node].hostname | default(node) }}"

# --- Cleanup mounts ---
- name: Unmount boot
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_boot"
    state: unmounted
  become: true

- name: Unmount root
  ansible.builtin.mount:
    path: "{{ work_dir }}/mnt_root"
    state: unmounted
  become: true
