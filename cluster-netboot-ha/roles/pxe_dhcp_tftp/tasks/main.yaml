- name: Setup initial requirements
  block:
    - name: Ensure required packages are installed
      ansible.builtin.package:
        name: rsync
        state: present

    - name: Ensure required directories exist
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      loop:
        - /srv/tftp
        - "{{ work_dir }}"
  become: true

# Get Raspberry Pi firmware (ZIP of the repo HEAD by default; override rpi_firmware_url if you like)
- name: Download Raspberry Pi firmware (patient + retries)
  ansible.builtin.get_url:
    url: "{{ rpi_firmware_url | default('https://github.com/raspberrypi/firmware/archive/refs/heads/master.zip') }}"
    dest: "{{ work_dir }}/rpi-fw.zip"
    mode: "0644"
    force: false
    timeout: 1800
    tmp_dest: "{{ work_dir }}"
    headers:
      User-Agent: "ansible-netboot-setup/1.0"
  register: fw_dl
  retries: 5
  delay: 10
  until: fw_dl is succeeded

- name: Unpack firmware
  ansible.builtin.unarchive:
    src: "{{ work_dir }}/rpi-fw.zip"
    dest: "{{ work_dir }}"
    remote_src: true
  become: true

# Find the directory that actually contains the boot files (start*.elf / fixup*.dat)
- name: Locate boot files directory
  ansible.builtin.find:
    paths: "{{ work_dir }}"
    patterns: "start*.elf"
    recurse: true
  register: fw_elfs

- name: Derive firmware boot dir
  ansible.builtin.set_fact:
    firmware_boot_dir: "{{ (fw_elfs.files | first).path | dirname }}"
  when: fw_elfs.files | length > 0

- name: Fail if boot files not found
  ansible.builtin.fail:
    msg: >-
      Could not locate Raspberry Pi boot files under {{ work_dir }}.
      Expected to find start*.elf / fixup*.dat after unpacking firmware.
  when: fw_elfs.files | length == 0


- name: Sync /boot files to TFTP root (local on nas-vm, via sudo)
  ansible.builtin.command: >
    rsync -a --delete
    --out-format='<<CHANGED>>%i %n%L'
    "{{ firmware_boot_dir }}/"
    "{{ tftp_root }}/"
  register: rsync_result
  changed_when: "'<<CHANGED>>' in rsync_result.stdout"
  become: true

# Note: Removed redundant individual file downloads - files are now extracted from Pi OS image or firmware archive

# Extract critical Pi 4 boot files from Raspberry Pi OS image for version consistency
# Note: Image is downloaded by k3s_common role to avoid duplication
- name: Check if Raspberry Pi OS image exists
  ansible.builtin.stat:
    path: "{{ work_dir }}/{{ raspios_url | basename }}"
  register: raspios_image_check

- name: Fail if shared Raspberry Pi OS image not found
  ansible.builtin.fail:
    msg: "Raspberry Pi OS image not found at {{ work_dir }}/{{ raspios_url | basename }}. Ensure k3s_common role runs first."
  when: not raspios_image_check.stat.exists

- name: Extract critical boot files from Raspberry Pi OS image
  block:
    - name: Create temporary mount directory
      ansible.builtin.file:
        path: "{{ work_dir }}/temp-mount"
        state: directory
        mode: "0755"

    - name: Decompress Raspberry Pi OS image
      ansible.builtin.shell: |
        cd {{ work_dir }}
        xz -d -k {{ raspios_url | basename }}
      args:
        creates: "{{ work_dir }}/{{ (raspios_url | basename) | regex_replace('\\.xz$', '') }}"

    - name: Get boot partition offset
      ansible.builtin.shell: |
        fdisk -l {{ work_dir }}/{{ (raspios_url | basename) | regex_replace('\.xz$', '') }} | grep "\.img1" | awk '{print $2 * 512}'
      register: boot_offset

    - name: Debug boot offset calculation
      ansible.builtin.debug:
        msg: "Boot offset calculated: {{ boot_offset.stdout }}"

    - name: Mount boot partition to extract critical files
      ansible.builtin.shell: |
        mount -o loop,offset={{ boot_offset.stdout }} {{ work_dir }}/{{ (raspios_url | basename) | regex_replace('\.xz$', '') }} {{ work_dir }}/temp-mount
      become: true
      when: boot_offset.stdout != ""

    - name: List available files in Pi OS boot partition for debugging
      ansible.builtin.shell: "ls -la {{ work_dir }}/temp-mount/ | head -20"
      register: boot_files_list
      become: true

    - name: Display available boot files
      ansible.builtin.debug:
        msg: "Available files in Pi OS boot partition: {{ boot_files_list.stdout_lines }}"

    - name: Check for armstub files in Pi OS boot partition
      ansible.builtin.shell: "ls {{ work_dir }}/temp-mount/armstub* || echo 'No armstub files found'"
      register: armstub_files
      become: true

    - name: Display armstub files found
      ansible.builtin.debug:
        msg: "Armstub files found: {{ armstub_files.stdout_lines }}"

    - name: Copy available Pi 4 boot files to TFTP root
      ansible.builtin.copy:
        src: "{{ work_dir }}/temp-mount/{{ item }}"
        dest: "{{ tftp_root }}/{{ item }}"
        mode: "0644"
        remote_src: true
      loop:
        - kernel8.img
        - bcm2711-rpi-4-b.dtb
        - bcm2711-rpi-400.dtb
        - bcm2711-rpi-cm4.dtb
      become: true
      ignore_errors: true

    - name: Copy armstub files if they exist (may have different names)
      ansible.builtin.shell: |
        cd "{{ work_dir }}/temp-mount"
        for armstub_file in armstub*.bin; do
          if [ -f "$armstub_file" ]; then
            cp "$armstub_file" "{{ tftp_root }}/"
            echo "Copied $armstub_file"
          fi
        done
        # Also check for armstub8-gic.bin specifically and create from armstub8.bin if needed
        if [ -f "armstub8.bin" ] && [ ! -f "{{ tftp_root }}/armstub8-gic.bin" ]; then
          cp "armstub8.bin" "{{ tftp_root }}/armstub8-gic.bin"
          echo "Created armstub8-gic.bin from armstub8.bin"
        fi
      become: true
      ignore_errors: true

    - name: Copy overlays directory from Pi OS image
      ansible.builtin.shell: |
        if [ -d "{{ work_dir }}/temp-mount/overlays" ]; then
          rsync -a "{{ work_dir }}/temp-mount/overlays/" "{{ tftp_root }}/overlays/"
        fi
      become: true
      ignore_errors: true

    - name: Unmount temporary mount
      ansible.builtin.shell: "umount {{ work_dir }}/temp-mount"
      become: true
      ignore_errors: true

    - name: Clean up temporary files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ work_dir }}/temp-mount"
        - "{{ work_dir }}/{{ (raspios_url | basename) | regex_replace('\\.xz$', '') }}"
      ignore_errors: true
  become: true


# Create overlays directory if it doesn't exist
- name: Create overlays directory
  ansible.builtin.file:
    path: "{{ tftp_root }}/overlays"
    state: directory
    mode: "0755"
  become: true

- name: Verify essential boot files exist in TFTP root
  ansible.builtin.stat:
    path: "{{ tftp_root }}/{{ item }}"
  register: boot_files_check
  loop:
    - bootcode.bin
    - start4.elf
    - fixup4.dat
    - kernel8.img
  failed_when: not boot_files_check.stat.exists
  become: true

- name: Check for any armstub file in TFTP root
  ansible.builtin.shell: "ls {{ tftp_root }}/armstub*.bin 2>/dev/null || echo 'No armstub files found'"
  register: tftp_armstub_check
  become: true

- name: Display armstub status in TFTP root
  ansible.builtin.debug:
    msg: "Armstub files in TFTP root: {{ tftp_armstub_check.stdout_lines }}"

- name: Warn if no armstub file found
  ansible.builtin.debug:
    msg: "WARNING: No armstub files found. Pi 4B netboot may fail. Consider downloading from alternative source."
  when: "'No armstub files found' in tftp_armstub_check.stdout"

# Ensure armstub8-gic.bin exists since Pi 4B requires it for netboot
- name: Check if armstub8-gic.bin specifically exists
  ansible.builtin.stat:
    path: "{{ tftp_root }}/armstub8-gic.bin"
  register: armstub_gic_check
  become: true

- name: Create armstub8-gic.bin from firmware if missing
  block:
    - name: Check for armstub8.bin in firmware directory
      ansible.builtin.stat:
        path: "{{ firmware_boot_dir }}/armstub8.bin"
      register: firmware_armstub8
      become: true

    - name: Copy armstub8.bin from firmware as armstub8-gic.bin
      ansible.builtin.copy:
        src: "{{ firmware_boot_dir }}/armstub8.bin"
        dest: "{{ tftp_root }}/armstub8-gic.bin"
        mode: "0644"
        remote_src: true
      become: true
      when: firmware_armstub8.stat.exists

    - name: Download armstub8-gic.bin from primary source if still missing
      ansible.builtin.get_url:
        url: "https://github.com/raspberrypi/firmware/raw/master/boot/armstub8-gic.bin"
        dest: "{{ tftp_root }}/armstub8-gic.bin"
        mode: "0644"
        force: false
        timeout: 300
        headers:
          User-Agent: "ansible-netboot-setup/1.0"
      register: armstub_download_primary
      retries: 3
      delay: 5
      until: armstub_download_primary is succeeded
      become: true
      when: not firmware_armstub8.stat.exists
      ignore_errors: true

    - name: Download armstub8-gic.bin from alternative source if primary fails
      ansible.builtin.get_url:
        url: "https://archive.raspberrypi.org/debian/pool/main/r/raspi-firmware/raspi-firmware_1.20231025-1_armhf.deb"
        dest: "{{ work_dir }}/raspi-firmware.deb"
        mode: "0644"
        force: false
        timeout: 300
        headers:
          User-Agent: "ansible-netboot-setup/1.0"
      register: armstub_package_download
      retries: 3
      delay: 5
      until: armstub_package_download is succeeded
      become: true
      when: 
        - not firmware_armstub8.stat.exists
        - armstub_download_primary is failed
      ignore_errors: true

    - name: Extract armstub8-gic.bin from downloaded package
      ansible.builtin.shell: |\
        cd {{ work_dir }}
        ar x raspi-firmware.deb data.tar.xz
        tar -xf data.tar.xz ./boot/armstub8-gic.bin --strip-components=1
        cp armstub8-gic.bin {{ tftp_root }}/
        rm -f data.tar.xz raspi-firmware.deb armstub8-gic.bin
      become: true
      when: 
        - not firmware_armstub8.stat.exists
        - armstub_download_primary is failed
        - armstub_package_download is succeeded
      ignore_errors: true

    - name: Final fallback - create dummy armstub8-gic.bin if all else fails
      ansible.builtin.shell: |
        # Create a minimal armstub file as last resort
        # This may not work perfectly but prevents the "file not found" error
        if [ ! -f "{{ tftp_root }}/armstub8-gic.bin" ]; then
          echo "Creating minimal armstub8-gic.bin as fallback"
          dd if=/dev/zero of="{{ tftp_root }}/armstub8-gic.bin" bs=1024 count=32 2>/dev/null
        fi
      become: true
      when: not armstub_gic_check.stat.exists
  when: not armstub_gic_check.stat.exists

- name: Install dnsmasq
  ansible.builtin.package:
    name: dnsmasq
    state: present
  become: true

- name: Stop and disable tftpd-hpa (conflicts with dnsmasq TFTP)
  ansible.builtin.systemd:
    name: tftpd-hpa
    state: stopped
    enabled: false
  become: true
  ignore_errors: true

- name: Stop dnsmasq if running
  ansible.builtin.systemd:
    name: dnsmasq
    state: stopped
  become: true
  ignore_errors: true

- name: Check what's using port 53
  ansible.builtin.shell: "lsof -i :53 || netstat -tulnp | grep :53 || true"
  register: port53_check
  become: true

- name: Display what's using port 53
  ansible.builtin.debug:
    msg: "Port 53 usage: {{ port53_check.stdout_lines }}"

- name: Clean up conflicting DNS services
  block:
    - name: Stop systemd-resolved completely
      ansible.builtin.systemd:
        name: systemd-resolved
        state: stopped
        enabled: false
      ignore_errors: true

    - name: Kill conflicting DNS processes
      ansible.builtin.shell: |
        # Kill dnsmasq processes
        pkill -f dnsmasq || true
        # Kill systemd-resolved processes
        pkill -f systemd-resolved || true
        # Kill any other processes using port 53
        for pid in $(lsof -t -i :53 2>/dev/null || true); do
          if [ -n "$pid" ]; then
            echo "Killing process $pid using port 53"
            kill -9 "$pid" || true
          fi
        done
      ignore_errors: true
  become: true

- name: Disable systemd-resolved DNS stub listener
  ansible.builtin.lineinfile:
    path: /etc/systemd/resolved.conf
    regexp: '^#?DNSStubListener='
    line: 'DNSStubListener=no'
    backup: true
  become: true

- name: Remove /etc/resolv.conf symlink if it exists
  ansible.builtin.file:
    path: /etc/resolv.conf
    state: absent
  become: true

- name: Create new /etc/resolv.conf
  ansible.builtin.copy:
    content: |
      nameserver {{ router_ip }}
      nameserver 8.8.8.8
    dest: /etc/resolv.conf
    backup: true
  become: true

- name: Wait for ports to be fully released
  ansible.builtin.pause:
    seconds: 5

- name: Final check - what's still using port 53
  ansible.builtin.shell: "lsof -i :53 || netstat -tulnp | grep :53 || echo 'Port 53 is free'"
  register: port53_final
  become: true

- name: Display final port 53 status
  ansible.builtin.debug:
    msg: "Final port 53 status: {{ port53_final.stdout_lines }}"

- name: Detect actual network interface
  ansible.builtin.shell: "ip route | grep default | awk '{print $5}' | head -1"
  register: detected_interface
  become: true

- name: Display detected interface
  ansible.builtin.debug:
    msg: "Detected interface: {{ detected_interface.stdout }}, configured: {{ net_iface }}"

- name: Override interface if detection differs
  ansible.builtin.set_fact:
    net_iface: "{{ detected_interface.stdout }}"
  when: detected_interface.stdout != net_iface and detected_interface.stdout != ""

- name: Remove any existing dnsmasq configuration
  ansible.builtin.file:
    path: /etc/dnsmasq.conf
    state: absent
  become: true

- name: Remove dnsmasq configuration directory contents
  ansible.builtin.shell: "rm -f /etc/dnsmasq.d/*"
  become: true
  ignore_errors: true

- name: Create clean dnsmasq configuration
  ansible.builtin.template:
    src: dnsmasq.conf.j2
    dest: /etc/dnsmasq.conf
    mode: '0644'
  become: true

- name: Test dnsmasq configuration syntax
  ansible.builtin.command: "dnsmasq --test -C /etc/dnsmasq.conf"
  register: dnsmasq_test
  become: true

- name: Display dnsmasq test results
  ansible.builtin.debug:
    msg: "dnsmasq config test: {{ dnsmasq_test.stdout_lines }}"

- name: Start and enable dnsmasq
  ansible.builtin.systemd:
    name: dnsmasq
    state: started
    enabled: true
    daemon_reload: true
  become: true

# Final verification of netboot setup
- name: Verify complete netboot file structure
  block:
    - name: Check for all essential netboot files
      ansible.builtin.stat:
        path: "{{ tftp_root }}/{{ item }}"
      register: final_files_check
      loop:
        # Core bootloader files
        - bootcode.bin
        # GPU firmware files
        - start.elf
        - start4.elf
        - start_x.elf
        - start4x.elf
        # Memory split files
        - fixup.dat
        - fixup4.dat
        - fixup_x.dat
        - fixup4x.dat
        # ARM stub file (critical for Pi 4)
        - armstub8-gic.bin
        # Kernel and device tree
        - kernel8.img
        - bcm2711-rpi-4-b.dtb
        # Overlays directory
        - overlays
      become: true

    - name: Report missing critical files
      ansible.builtin.debug:
        msg: "WARNING: Missing critical netboot file {{ item.item }}"
      loop: "{{ final_files_check.results }}"
      when: not item.stat.exists

    - name: Count successful file installations
      ansible.builtin.set_fact:
        netboot_files_present: "{{ final_files_check.results | selectattr('stat.exists') | list | length }}"
        netboot_files_total: "{{ final_files_check.results | length }}"

    - name: Display netboot setup summary
      ansible.builtin.debug:
        msg: |
          Raspberry Pi Netboot Setup Summary:
          - Files present: {{ netboot_files_present }}/{{ netboot_files_total }}
          - TFTP root: {{ tftp_root }}
          - DHCP/TFTP service: dnsmasq (running)
          - Network interface: {{ net_iface }}
          - DHCP range: {{ dhcp_start }}-{{ dhcp_end }}
          
          Setup is {{ 'COMPLETE' if netboot_files_present == netboot_files_total else 'INCOMPLETE' }}
          {{ 'All Raspberry Pi nodes should now be able to netboot successfully.' if netboot_files_present == netboot_files_total else 'Some files are missing - check logs above for details.' }}

    - name: Fail if critical files are missing
      ansible.builtin.fail:
        msg: |
          Netboot setup incomplete: {{ netboot_files_total - netboot_files_present }} files missing.
          This will prevent Raspberry Pi nodes from booting successfully.
          Check the download errors above and network connectivity.
      when: netboot_files_present < (netboot_files_total * 0.8)  # Allow some non-critical files to be missing
  become: true
